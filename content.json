[{"title":"mongodb的安装与移植(ubuntu16.04)","date":"2018-03-13T06:06:18.000Z","path":"2018/03/13/mongodb的安装与移植-ubuntu16-04/","text":"近期把我的论坛从国外服务器移植到国内服务器，记录下把数据库移植的一些笔记 环境：ubuntu16.04 mongodb3.6 的安装1234567891011# 1. Import the public key used by the package management system$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5# 2.Create a list file for MongoDB$ echo \"deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.6 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list# 3. Reload local package database.$ sudo apt-get update# 4. Install the MongoDB packages$ sudo apt-get install -y mongodb-org 安装好后，就可以通过 service mongod start 启动 mongodb 服务端 如果提示Failed to start mongodb.service: Unknown unit: mongodb.servicesudo systemctl enable mongod 来修复。 mongodb 数据的移植1. 备份数据库（数据导出）12# 把数据库的数据备份到 outpath 中，备份名为 月-日-年 格式$ sudo mongodump --db dbname --out outpath/`date+\"%m-%d-%y\"` 2. 恢复和迁移数据 把第1步生成的数据库备份文件拷贝到你想迁移的服务器 12# 把备份的数据库（pathOfBackup/dbname）迁移生成新数据库（newdbname）$ sudo mongorestore --newdbname --drop pathOfBackup/dbname","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"前端开发","date":"2017-11-11T07:40:25.000Z","path":"2017/11/11/前端开发/","text":"在几次的项目开发中，总结了一下。 项目总会迭代。很少能一次性写好（需求变更，技术变更等 对于一些复杂的效果，先不要实现，放个无效果的顶替先。 实现一些复杂动态效果时，往往思路会陷入到一些额外的东西去（例如：性能阿，动作的连贯性等），应该先抛开这些东西，先不考虑复杂度，性能等，把效果粗糙的做出来。 接上，实现完后，再来考虑怎么优化，然后优化到最简便的状态。 经过 3 4 步后，代码很可能存在冗余了。此时应 review 代码，去除冗余。 前端经常涉及到自己涉及到组件开发，本质就是写个函数，核心应该放在组件接口的设计，该传什么参数进去，该返回什么，组件里只应有功能逻辑，不能有业务逻辑。","categories":[],"tags":[{"name":"项目开发","slug":"项目开发","permalink":"http://yoursite.com/tags/项目开发/"}]},{"title":"Promise的实现","date":"2017-09-17T09:10:55.000Z","path":"2017/09/17/Promise的实现/","text":"每次用 promise 总觉得很有意思，近期近下心来研究研究，实现了一个 promise。 promise 是为了解决回调地狱的问题。主要有以下几个方法12341. Promise.prototype.then2. Promise.prototype.catch3. Promise.all4. Promise.race 废话不说了，直接放代码。欢迎不吝赐教。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133const log = console.log.bind(console)class BananasPromise &#123; constructor(func) &#123; if(typeof func !== 'function') &#123; throw new Error(func, 'is no a function') &#125; this.func = func this.state = 'init' const resolve = this.resolve.bind(this) const reject = this.reject.bind(this) const r = () =&gt; &#123; func(resolve, reject) return this &#125; return r &#125; _efunc() &#123; &#125; then(done) &#123; this.done = done || this._efunc if(this.state === 'done') &#123; done(this.args) &#125; return this &#125; catch(fail) &#123; this.fail = fail || this._efunc if(this.state === 'fail') &#123; fail(this.err) &#125; &#125; resolve(args='') &#123; this.state = 'done' this.args = args this.done &amp;&amp; this.then(this.done) &#125; reject(args='') &#123; this.state = 'fail' this.err = args this.catch &amp;&amp; this.catch(this.fail) &#125; static _init() &#123; const cls = this cls.state = 'init' cls.done = () =&gt; &#123;&#125; cls.fail = () =&gt; &#123;&#125; cls._resule = [] cls._err = null &#125; static all(array) &#123; const cls = this let len = array.length cls._init() array.forEach((i, index) =&gt; &#123; if(cls._err !== null) &#123; return &#125; i().then((a) =&gt; &#123; if(cls._err !== null) &#123; return &#125; len-- cls._resule[index] = a if(len === 0) &#123; cls.state = 'done' cls.then() &#125; &#125;).catch((err) =&gt; &#123; if(cls._err !== null) &#123; return &#125; cls.state = 'fail' cls._err = err cls.catch() &#125;) &#125;) return this &#125; static then(done) &#123; const cls = this if(this.state === 'done') &#123; cls.done(cls._resule) &#125; else if(this.state === 'init') &#123; cls.done = done || cls.done &#125; return this &#125; static catch(fail) &#123; const cls = this if(cls.state === 'fail') &#123; cls.fail(cls._err) &#125; else if(cls.state === 'init') &#123; cls.fail = fail || cls.fail &#125; &#125; static race(array) &#123; const cls = this cls._init() array.forEach((item) =&gt; &#123; if(cls.state === 'done' || cls.state === 'fail') &#123; return &#125; item().then((data) =&gt; &#123; if(cls.state === 'done' || cls.state === 'fail') &#123; return &#125; cls.state = 'done' cls._resule = data cls.then() &#125;).catch((err) =&gt; &#123; if(cls.state === 'done' || cls.state === 'fail') &#123; return &#125; cls.state = 'fail' cls._err = err cls.catch() &#125;) &#125;) return cls &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Atom配置","date":"2017-04-16T17:27:37.000Z","path":"2017/04/17/Atom配置/","text":"分享下我用 atom 开发的一些快捷键和插件 1. atom 修改快捷键 ( 在 setting &gt; keybindings &gt; your keymap file 中123456789101112131415161718192021222324252627282930313233343536373839# cmd 对应 win 键&apos;atom-text-editor&apos;: # 新建行 &apos;shift-enter&apos;: &apos;editor:newline-below&apos; # 上 下 左 右 &apos;ctrl-n&apos;:&apos;core:move-down&apos; &apos;ctrl-p&apos;:&apos;core:move-up&apos; &apos;ctrl-f&apos;:&apos;core:move-right&apos; &apos;ctrl-b&apos;:&apos;core:move-left&apos; &apos;ctrl-cmd-b&apos;: &apos;editor:move-to-beginning-of-word&apos; &apos;ctrl-cmd-f&apos;: &apos;editor:move-to-end-of-word&apos; # 跳到行头&amp;尾 &apos;ctrl-e&apos;: &apos;editor:move-to-end-of-screen-line&apos; &apos;ctrl-a&apos;: &apos;editor:move-to-first-character-of-line&apos; # 删除单词 &apos;ctrl-cmd-h&apos;: &apos;editor:delete-to-beginning-of-word&apos; &apos;ctrl-cmd-d&apos;: &apos;editor:delete-to-end-of-word&apos; &apos;ctrl-h&apos;:&apos;core:backspace&apos; &apos;ctrl-d&apos;:&apos;core:delete&apos; # 选中 &apos;ctrl-shift-b&apos;: &apos;editor:select-to-beginning-of-word&apos; &apos;ctrl-shift-f&apos;: &apos;editor:select-to-end-of-word&apos;&apos;.platform-win32 atom-text-editor, .platform-linux atom-text-editor&apos;: # 查找 &apos;cmd-f&apos;: &apos;find-and-replace:show&apos;&apos;atom-workspace atom-text-editor&apos;: # 全选 &apos;cmd-a&apos;:&apos;core:select-all&apos;&apos;body&apos;: # 新建文件 &apos;cmd-n&apos;:&apos;application:new-file&apos; 2. 实用插件 advanced-open-file hyperclick atom-beautify js-hyperclick atom-javascript-snippets minimap remote-ftp autoclose-html minimap-bookmarks docblockr minimap-highlight-selected git-plus pigments highlight-selected platformio-atom-ide-terminal 3. 主题 seti-ui seti-syntax","categories":[],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/tags/开发工具/"}]},{"title":"node的几种路径问题","date":"2017-04-05T12:08:23.000Z","path":"2017/04/05/node的几种路径问题/","text":"node 中有几种代表 路径 的变量，下面在介绍介绍 __dirname __filename process.cwd() ./","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"CommonJs","date":"2017-04-05T07:43:56.000Z","path":"2017/04/05/CommonJs/","text":"关于 commonjs 的一些笔记 默认每个文件的变量为私有，作用域只在这一文件中要共享变量：用 global module 变量代码当前模块exports xx 导出对外接口 特点： 模块化作用域 具有缓存机制，多次加载只运行一次，即第二次加载时读取缓存结果 多模块加载的顺序按照其在代码中的顺序 规则： require(xxx.js) 可省略 .js 后缀，即 require(xxx) 模块搜索顺序123456require('bar.js')1. /usr/local/lib/node/bar.js // 若找不到，下步2. ./node_module/bar,js // 若找不到，下步3. /home/user/node_module/bar.js4. /home/node_module/bar.js5. /node_module/bar.js","categories":[],"tags":[{"name":"js杂记","slug":"js杂记","permalink":"http://yoursite.com/tags/js杂记/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"package.json","date":"2017-04-05T05:41:44.000Z","path":"2017/04/05/package-json/","text":"本文介绍 package.json 文件 package.json 定义了项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等信息）。npm install 命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 用 npm init 可生成 package.json 文件 以下是一个比较长见的 package.json 文件 123456789101112131415161718192021222324252627282930313233&#123; // 项目名称 \"name\": \"Hello World\", \"author\": \"香蕉\", \"description\": \"这是xx工程\", // 指明了该项目所需要的node.js版本 \"engines\": &#123;\"node\": \"0.10.x\"&#125;, // scripts 指定了运行脚本命令的npm命令行缩写， // 如下 运行 npm run start 时，就会执行 node index.js 指令。 \"scripts\": &#123; \"start\": \"node index.js\" &#125;, // 指定了项目运行所依赖的模块 \"dependencies\": &#123; // value 指定了该模块所需的 版本，详情见下面 \"express\": \"latest\", \"mongoose\": \"~3.8.3\", \"handlebars-runtime\": \"~1.0.12\", \"express3-handlebars\": \"~0.5.0\", \"MD5\": \"~1.2.0\" &#125;, // 指定项目开发所需要的模块。 \"devDependencies\": &#123; \"bower\": \"~1.2.8\", \"grunt\": \"~0.4.1\", \"grunt-contrib-concat\": \"~0.3.0\", \"grunt-contrib-jshint\": \"~0.7.2\", \"grunt-contrib-uglify\": \"~0.2.7\", \"grunt-contrib-clean\": \"~0.5.0\", \"browserify\": \"2.36.1\", \"grunt-browserify\": \"~1.3.0\", &#125;&#125; 模块 版本的指定 指定版本：比如 1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。 波浪号（tilde） + 指定版本：比如 ~1.2.2，表示安装 1.2.x 的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。 插入号（caret）+指定版本：比如 ˆ1.2.2，表示安装 1.x.x 的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 latest：安装最新版本。 参考资料 ：阮一峰: package.json 文件","categories":[],"tags":[{"name":"js杂记","slug":"js杂记","permalink":"http://yoursite.com/tags/js杂记/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"node在linux下的安装","date":"2017-03-27T04:36:22.000Z","path":"2017/03/27/node在linux下的安装/","text":"Node 的安装（linux）用 apt-get install nodejs（ubuntu）安装后的版本只有 4.2 ，版本太低了，太操蛋了 要使用 v7.x 版本，我摸索许久，得出 2 种靠谱的方法 1. 用 linux 包管理器安装（最简单）node 包管理器安装指南,各位可以根据各自的系统找到相对应的命令敲到终端 2. 使用 nodejs 源码安装（时间超久）1234567891011# 获取源码包wget https://nodejs.org/dist/v7.7.2/node-v7.7.2.tar.gz# 解压tar xvf node-v7.7.2.tar.gz# 安装(使用 root 权限)cd node-v7.7.2./configuremakemake install","categories":[],"tags":[{"name":"js杂记","slug":"js杂记","permalink":"http://yoursite.com/tags/js杂记/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"反向代理","date":"2017-02-18T13:33:32.000Z","path":"2017/02/18/反向代理/","text":"利用 nginx 反向代理当只有一台服务器，而又想运行多个 web 后端服务，且希望网址为 www.XX.com / bbs.XX.com / blog.XX.com,怎么办，此时就要用nginx进行反向代理 以 ubuntu 为例 1. 安装 nginx1$ sudo apt-get install nginx 2. 修改 nginx 的配置文件12# 配置文件在 /etc/nginx/nginx.confcd /etc/nginx 然后修改 nginx.conf,具体为:修改配置文件中 的 http{} 在 http{} 中的末尾补上反向代理配置代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283user www-data;worker_processes auto;pid /run/nginx.pid;events &#123; worker_connections 768; # multi_accept on;&#125;http &#123; ## # 前面的代码再此不展示了,在 http&#123;&#125; 中补上以上代码 ## ## # 反向代理配置代码 ## # 注意端口号 8081 为 bbs 服务, 8082 为 blog 服务,8083 为 www 服务 upstream bbs &#123; server 127.0.0.1:8081 weight=1; &#125; upstream blog &#123; server 127.0.0.1:8082 weight=1; &#125; upstream www &#123; server 127.0.0.1:8083 weight=1; &#125; server&#123; listen 80; # 配置 www.bigbananas.cn server_name www.bigbananas.cn; access_log /var/log/nginx/www.log; location / &#123; root /home/website_root; &#125; &#125; server&#123; listen 80; # 配置 blog.bigbananas.cn server_name blog.bigbananas.cn; access_log /var/log/nginx/blog_access.log; location / &#123; root /home/todo_root; # proxy_pass 为反向代理后的 网站 proxy_pass http://127.0.0.1:8081/; proxy_read_timeout 300; proxy_connect_timeout 300; proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125; &#125; server&#123; listen 80; # 配置 bbs.bigbananas.cn server_name bbs.bigbananas.cn; access_log /var/log/nginx/bbs_access.log; location / &#123; root /home/todo_root; # proxy_pass 为反向代理后的 网站 proxy_pass http://127.0.0.1:8082/; proxy_read_timeout 300; proxy_connect_timeout 300; proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; &#125; &#125;&#125; 3. 在重启 nginx 服务1$ sudo nginx -s reload 4. 在服务器启动 blog、bbs、www 服务注意： 端口号 8081 为 bbs 服务, 8082 为 blog 服务,8083 为 www 服务 参考文章ubuntu 彻底删除 nginx nginx 的一些命令的使用 nginx 反向代理介绍 nginx 反向代理配置","categories":[],"tags":[{"name":"web后端","slug":"web后端","permalink":"http://yoursite.com/tags/web后端/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"js 定时器使用","date":"2017-01-29T10:17:10.000Z","path":"2017/01/29/js-定时器使用/","text":"js 定时器setTimeout 和 setInterval 使用 setTimeout(code, time) 其中 code 应为一个 function （即函数） 而不应该为 直接的代码 clearTimeout()，clearInterval() 清除计时器 12345var id1 = setTimeout(f,1000);var id2 = setInterval(f,1000);clearTimeout(id1);clearInterval(id2);","categories":[],"tags":[{"name":"js杂记","slug":"js杂记","permalink":"http://yoursite.com/tags/js杂记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"能力感想","date":"2017-01-18T18:12:39.000Z","path":"2017/01/19/能力感想/","text":"看了很多初学者一上来就找”精通XXX、精通YYY”的方法,觉得不好 一个人的价值是体现在精通某项技术吗?并不是。 不同的编程语言就想不同的工具罢了,关键是你能用这个工具做出个能用很屌的产品来。像大家都知道微信做的很屌,人们只会记住微信、腾讯,记住马化腾,记住张小龙,人们会去看你的代码用了 XX 高级写法吗？会记住某某程序员多屌多屌吗，写的代码多高级吗? 所以我们不用刻意追求用了多高级的写法，把功能实现出来就行了，精力用在你有兴趣的地方。 注意：我不是反对精通技术不好,你有兴趣专研就好了。举个例子,人们会用锤子做出一个书架、桌子、椅子,但没必要因为用了锤子而花精力去研究锤子高级用法、锤子是怎么来了、怎么制造一把锤子，当然你也可以研究锤子，做个锤子大师。不过这种毕竟是少数人。 我们是人，我们不是机器，我们使用工具，不应该被工具折磨，工具不好使换一把就得了。 还要不要迷恋底层，底层我们了解下就行，毕竟做底层的需求很少 有 汇编语言 我精通 机器码 干屌。 有 C 语言，我精通 汇编 干屌。 有 Java 我精通 C 语言 干屌。 有 JavaScript，我精通 Java 干屌。 为什么说偏向学高级语言而不学低级的呢，因为我们是人，我们需要花精力去注意 每行代码后加个冒号 这种事吗？这种事情让编译器去做就行了 再来个例子，电脑在 1946 发明，为什么在 1996 年电脑才大规模普及，因为人们 1996 突然就必须用电脑吗？并不是。除了价格减低的原因外，最重要的是电脑实现了界面化，想想你会为了删个文件而学了一堆指令吗？记指令这种事操作系统去记就行了，你只要把文件拉到垃圾箱就行了。你的精力应该用在制造有价值的地方上，例如用电脑做个 EXCEL 表格。","categories":[],"tags":[{"name":"个人杂想","slug":"个人杂想","permalink":"http://yoursite.com/tags/个人杂想/"}]},{"title":"原生 EMACscript 接口","date":"2017-01-16T14:32:38.000Z","path":"2017/01/16/原生-ECMAscript-接口/","text":"本博客用来记录用过的 浏览器原声 JavaScript 接口 .insertAdjacentHTML beforebegin afterbegin beforeend afterend .dataset.XX document.addEventListener(“DOMContentLoaded”, function(event) { //do work __main() }) 等价于 jQuery 的 $(document).ready(function(){})","categories":[],"tags":[{"name":"js杂记","slug":"js杂记","permalink":"http://yoursite.com/tags/js杂记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"浏览器接口","slug":"浏览器接口","permalink":"http://yoursite.com/tags/浏览器接口/"}]},{"title":"CSS & HTML","date":"2017-01-16T14:27:11.000Z","path":"2017/01/16/CSS-HTML/","text":"本博客用来记录用过的 HTML &amp; CSS HTML placeholder // input 框的默认值 request &amp; form &amp; sumbit // input 必须填写 disabled // button 属性 input 事件 CSS pointer-events:none // 事件穿透 box-shadow: 10px 10px 5px #888888; rgba(R, G, B, A) vw/vh 名称 单位 描述 Viewport Width vw 视窗(Viewport)宽度的1/100 Viewport Height vh 视窗(Viewport)高度的1/100 Minimum Viewport vmin 视窗(Viewport)较小的那个尺寸的1/100（高度或宽度） Maximum Viewport vmax 视窗(Viewport)较大的那个尺寸的1/100（高度或宽度） 5. 元素外尺寸 元素边框尺寸 元素滚动尺寸 offsetWidth clientWidth scrollWidth offsetHeight clientHeight scrollHeight offsetLeft clientLeft scrollLeft offsetTop clientTop scrollTop clientHeight和clientWidth用于描述元素内尺寸，是指 元素内容+内边距 大小，不包括边框（IE下实际包括）、外边距、滚动条部分 offsetHeight和offsetWidth用于描述元素外尺寸，是指 元素内容+内边距+边框，不包括外边距和滚动条部分 clientTop和clientLeft返回内边距的边缘和边框的外边缘之间的水平和垂直距离，也就是左，上边框宽度 offsetTop和offsetLeft表示该元素的左上角（边框外边缘）与已定位的父容器（offsetParent对象）左上角的距离 offsetParent对象是指元素最近的定位（relative,absolute）祖先元素，递归上溯，如果没有祖先元素是定位的话，会返回null background(button): linear-gradient(to bottom, #6a9bff, #0088cc); cursor: not-allowed // 鼠标样式 user-select: none; -webkit-user-select: none; // 禁止选中文字","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"运用 node 部署个人 blog 服务端","date":"2017-01-09T15:29:50.000Z","path":"2017/01/09/部署个人-blog-服务端/","text":"准备工作：需先在本地把 express 博客程序写好。把 appBlog.js 中最后的端口 8081 设为 80文件结构如图 0. 购买服务器, 我用的是腾讯云（学生党1元/月） 系统选择 ubuntu 16.04 LTS / 64 位 设置 用户名 和 密码 记得服务器的 IP 地址 1. 把 本地博客文件夹 上传到 云服务器 下载pscp.exe,用来上传文件到服务器 将下载的 pscp.exe 复制到C:\\WINDOWS\\system32\\，这样可以在命令行下使用 pscp 命令了 打开命令行 cmd 其中 banshu 是博客程序所在的文件夹.pscp 命令使用介绍： pscp -r 本地文件夹 &lt;用户名&gt;@&lt;ip地址&gt;:&lt;服务器目录&gt;. 123# 注: # 号后面是注释&gt; cd &lt;博客所在文件夹的上一层&gt;&gt; pscp -r banshu &lt;云服务器的用户名&gt;@&lt;云服务器的ip地址&gt;:/home/ 以上就把博客程序的文件夹上传到云服务器中了（在服务器的 /home/ 目录下可看到） 2. 配置云服务器 登录服务器（在服务器所在的官网可以登录） 安装 node 和 npm 123$ sudo apt update $ sudo apt install nodejs-legacy # 安装 node$ sudo apt install npm # 安装 npm 开启 express 服务 123# banshu 是第 1 步上传的博客程序文件夹$ cd /home/banshu $ sudo node appBlog.js # 启动 express 服务 3. 在浏览器地址栏中输入云服务器的 ip 地址即可看到自己的 blog ！","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/tags/工具使用/"},{"name":"window","slug":"window","permalink":"http://yoursite.com/tags/window/"}]},{"title":"ubuntu 下为 npm 代理加速","date":"2017-01-08T15:18:55.000Z","path":"2017/01/08/ubuntu-下为-npm-代理加速/","text":"npm 的服务器在国外, 因为国情,经常访问缓慢,故搭配我的 ss 给 npm 代理加速 先配置 ss因为 npm 代理是走 http 的通道,而 shadowsocks 提供的是 socks5 通道,故需要将 shadowsocks 的 sock5 通道 转换为 http 通道 有 2 种方法 1. 将 ss 本地端配置成 http(s) 类型 (方便)若你的 ss 客户端支持把 本地端配置成 http 类型 ,就将其配置成 http(s) 类型即可 2. 安装 kneesocks 包,作用:将 http 包转换为 sock5 类型的包12$ npm install kneesocks -g # 下载安装 kneesocks 包$ DEBUG=proxy kneesocks httpPort sock5Port # 开启 kneesocks 转换 注:若 node 版本高于 7 时, 需将 .npm-global/lib/node_modules/kneesocks/node_modules/socksv5/lib/client.js`修改成 client.js 再配置 npm12$ npm config set proxy http://127.0.0.1:httpPort$ npm config set https-proxy http://127.0.0.1:httpPort","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/tags/工具使用/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"eval() 方法","date":"2016-12-27T05:00:38.000Z","path":"2016/12/27/eval-方法/","text":"eval() 方法像是一个 js 解析器,它只接受一个参数,即要执行的 js 语句的字符串 注意: eval() 功力太强,能不用就不用,用不好就gg了 1234// 例eval('console.log('halo')')// 等价于console.log('halo') eval() 中创建的任何变量和函数都不会被提升(因为这些变量和函数实在执行 eval() 时才被创建的 )","categories":[],"tags":[{"name":"js高程读书笔记","slug":"js高程读书笔记","permalink":"http://yoursite.com/tags/js高程读书笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"this & arguments","date":"2016-12-26T14:29:45.000Z","path":"2016/12/26/this-arguments/","text":"在函数内部,有两个特殊的对象: arguments 和 this 1. arguments 主要用途是 保存函数参数 argument 对象还要一个 callee 的属性,该属性指向 拥有 arguments 对象的函数 123456789// 以阶乘函数为例var factorial = function(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; // 注意以下这行, arguments.callee 即 factorial 函数 return num * arguments.callee(num-1) &#125;&#125; 2. this 对象代表函数据以执行的执行环境的变量对象(可参考上一文章)1234567891011121314// 例子var color = 'red'var o = &#123; color: 'blue'&#125;//var sayColor = function() &#123; console.log(this.color)&#125;//sayColor() // red//o.sayC = sayColoro.sayC() // blue 另ES5 给函数添加了 caller 属性(作用:指向调用当前函数的函数(即当前函数他爸))","categories":[],"tags":[{"name":"js高程读书笔记","slug":"js高程读书笔记","permalink":"http://yoursite.com/tags/js高程读书笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"执行环境及作用域","date":"2016-12-26T12:09:35.000Z","path":"2016/12/26/执行环境及作用域/","text":"执行环境定义了变量或函数有权访问的其他数据,决定了他们各自的行为.每个执行环境都有一个与之关联的变量对象(用来保存执行环境中定义的所有变量和函数) 在 Web 浏览器中,全局执行环境(即最外层的执行环境)被认为是 window 对象. 机制:每一个函数都有自己的执行环境.当执行流进入一个函数时,函数的环境就会被推入一个环境栈中.而在函数执行之后,栈将其环境弹出,把控制权返回给之前的执行环境. 当代码在一个执行环境中执行时,会创建一个作用域链.作用域链的用途是:保证对执行环境有权访问的所有变量有序访问. 作用域链: 当前执行的代码所在的执行环境的变量对象(子) –&gt; 包含执行环境(父) –&gt; 下一个包含执行环境(爷) –&gt; …. –&gt; window 对象(最外层) 123456789var color = 'blue'//function changeColor() &#123; color = 'red'&#125;//changeColor()//console.log(color) // red 123456789var color = 'blue'//function changeColor() &#123; var color = 'red'&#125;//changeColor()//console.log(color) // blue","categories":[],"tags":[{"name":"js高程读书笔记","slug":"js高程读书笔记","permalink":"http://yoursite.com/tags/js高程读书笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"GitHub 远程库使用","date":"2016-12-26T08:12:26.000Z","path":"2016/12/26/GitHub-远程库使用/","text":"之前说过 git 本地使用记录,再说说 Github 的使用 1. 添加 SSHkey1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; # 不需要设密码(这样方便) 将生成的 SSHkey.pub 公钥 复制到 GitHub 个人账户的 SSH keys 中 2. 克隆 远程库1$ git clone git@github.com/userName/repositoryName # 复制 远程库 到 本地 3. 设置远程仓库123456$ git remote add origin git@github.com/userName/repositoryName # 设置 远程仓库 名为 origin$$ git remote remove orgin # 删除名为 orgin 的远程仓库的记录$$ git remote # 查看远程仓库 信息$ git remote -v # 查看远程仓库 详细信息 4. 将本地分支推送远程分支123$ git push -u orgin master # 第一次推到远程仓库,把当前分支推到远程仓库 master 分支$ git push orgin master # 把当前分支推到远程仓库 master 分支$ git push orgin &lt;本地分支名XX&gt;:&lt;远程分支名YY&gt; # 把本地XX分支推到远程仓库YY分支 5. 关联本地分支于远程分支 即设置本地分支 对应 远程哪个分支 12# 设置 本地分支XX 对应 远程分支YYgit branch --set-upstream &lt;本地分支名XX&gt; orgin/&lt;远程分支名YY&gt; 在第一次git push -u orgin master中的-u参数就是设置 当前分支 对应 远程 master 分支 要创建本地仓库和远程仓库对应的分支,可用以下指令12# 创建 本地分支xx ,该分支对应 远程分支YY$ git checkout -b &lt;本地分支名XX&gt; orgin/&lt;远程分支名YY&gt; 6. 将远程分支拉到本地分支12$ git pull # 根据 当前的本地分支(即 HEAD) 将相对应的 远程分支 拉到本地$ git pull orgin &lt;远程分支名&gt; # 将 远程仓库某一分支 拉到本地","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/tags/工具使用/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"git 本地使用命令记录","date":"2016-12-26T05:02:34.000Z","path":"2016/12/26/git-使用记录/","text":"git 指令几天不看,就忘了,故写个博客,记录下 1. 安装 git2. 自报家门12$ git config --global user.name 'Your Name'$ git config --global user.email 'email@email.com' 3. 创建 repository123456789$ git init # 将当前文件夹初始化为 git respiratory$$ git add &lt;fileName&gt; # 将 工作区的&lt;fileName&gt; 提交到 暂缓区$ git commit -m &lt;message&gt; # 将 暂缓区内容 提交到 版本库 中$$ git stauts # 查看当前工作区&amp;暂缓区的状态$$ git log # 查看版本库的历史记录$ git log --pretty=oneline --graph --abbrev-commit # git log 几个可选参数 4. 版本回滚 – // 代表 当前 版本HEAD // 代表 当前 版本HEAD^ // 代表 上一 版本HEAD^^ // 代表 上上 版本HEAD~100 // 代表 上100版 版本 1234$ git reset --hard HEAD # 回滚到 当前 版本$ git reset --hard HEAD^ # 回滚到 上一 版本$ git reset --hard HEAD^^ # 回滚到 上上 版本$ git reset --hard HEAD~100 # 回滚到 上100版 版本 回滚到特定的某一版本 $ git reflog 指令记录每一次命令,并提供 commit 号 先用$ git log或$ git reflog 看看某一版本的 commit 号,接着1$ git reset --hard &lt;commit 号&gt; # 回滚到 commit 号 的那一版 (其中 commit 号 可以只写前几位,为了区分不同版本) 5. 查看差异1234567$ git diff # 查看 工作区 和 暂缓区 的差异$ git diff --cached # 查看 暂缓区 和 当前版本库 的差异$ git diff HEAD # 查看 未提交(即未 git commit) 和 当前版本库 的差异$ git diff HEAD^ # 查看 未提交(即未 git commit) 和 上一版本库 的差异$ git diff dev # 查看 当前分支 和 dev 分支 的差异$ git diff master..dev # 查看 master 分支 和 dev 分支 的差异$ git diff --stat # 查看 总体 差异(哪些文件被修改等总体信息) 6. 撤销修改 HEAD 和 – 是一个意思,都代表 当前版本 的意思 12$ git checkout -- &lt;fileName&gt; # 撤销 工作区 的修改(还未提交到暂缓区前)$ git reset HEAD &lt;fileName&gt; # 将 暂缓区 的内容撤销回 工作区(已经提交到暂缓区但还未提交到版本库前) 若已经提交到版本库,则用版本回滚的方法回滚到上一版本$ git reset --hard HEAD^ 7. 删除文件12$ git rm &lt;fileName&gt; # 直接用 git rm 命令删除文件$ git commit -m &lt;message&gt; # 然后提交到版本库 8. 分支12345678910# 以下 dev 只是个分支名$ git branch dev # 创建 dev 分支$ git checkout dev # 将 当前分支(即 HEAD) 切换到 dev 分支# 以上 2 条指令等价于下面这条指令$ git checkout -b dev # 创建 dev 分支,并将当前分支(即 HEAD)切换到 dev 分支$$ git branch # 查看分支$$ git branch -d dev # 删除 dev 分支 (改分支合并过)$ git branch -D dev # 删除 dev 分支 (改分支未合并过) 9. 合并分支123# 以下 dev 只是个分支名$ git merge dev # 将 dev 分支 与 当前分支(即 HEAD) 合并( Fast forward 模式)$ git merge --no-ff -m \"message\" dev # 将 dev 分支 与 当前分支(即 HEAD) 合并(非 Fast forward 模式) 合并时有冲突,只需根据提示修改冲突文件,再合并 10. 暂存当前工作区&amp;暂缓区 (类似压栈/出栈)12345678910$ git stash # 暂存当前工作区&amp;暂缓区(类似压栈)$$ git stash apply # 将栈恢复到工作区&amp;暂缓区$ git stash drop # 将栈删除# 以上 2 步等价于下面这条指令$ git stash pop # 将栈恢复到工作区&amp;暂缓区,并将栈删除(类似出栈)$$ git stash list # 查看 栈 总体状态# 若有多个暂存(即栈里不止一个暂存),就指定 stash@&#123;n&#125; (stash@&#123;n&#125; 可在 git stash list 中找到)$ git stash apply stash@&#123;n&#125; # 恢复 stash@&#123;n&#125; 这个特定的暂存","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/tags/工具使用/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"基本包装类型","date":"2016-12-25T09:26:31.000Z","path":"2016/12/25/基本包装类型/","text":"JS 提供 3 个特殊的引用类型: Boolean Number String 每当读取一个 基本类型值 时,后台就会创建一个对应的 基本包装类型 的对象,从而让我们能够调用一些方法来操作这些数据.来看下面的例子. 123var s1 = 'some text'var s2 = s1.lengthconsole.log(s2) // 9 这个例子中的变量 s1 包含一个字符串, s1 是 基本类型值.之前的文章说过,基本类型没有方法和属性,那这里为什么可以用 var s2 = s1.length呢? 其实,为了让我们实现这种直观的操作,后套已经自动完成了一系列的处理.具体说就是,当我们访问这个这个基本类型值时,后台自动完成了一下步骤: 1. 创建 String 类型的一个实例;2. 在实例上调用指定的方法;3. 销毁这个实例 代码表现为:1234// 执行 s2 = s1.length 时,后台完成以下 3 步var s1 = new String('some text')var s2 = s1.lengths1 = null 这也解释了为什么基本类型不能添加属性和方法 123var s1 = 'halo's1.color = 'red'console.log(s1.color) // undefined 在此,第二行代码给 s1 添加一个 color 属性.但是,第三行代码访问 s1 时,其 color 属性不见了.这是因为第二行创建的 String 对象在执行第三行代码前已经被销毁了.执行第三行代码时又创建了自己的 String 对象,而该对象没有 color 属性","categories":[],"tags":[{"name":"js高程读书笔记","slug":"js高程读书笔记","permalink":"http://yoursite.com/tags/js高程读书笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"程序员之路","date":"2016-12-24T07:24:36.000Z","path":"2016/12/24/程序员之路/","text":"重要的是编程能力1. 简化问题的能力 拆封成几个小问题(如扫雷) 2. 快速开发的能力 大量练习打码 3. 解决别人不能解决的问题的能力编程能力会有平台期,重要的是坚持度过,就会有提升","categories":[],"tags":[{"name":"萧大语录","slug":"萧大语录","permalink":"http://yoursite.com/tags/萧大语录/"}]},{"title":"基本变量&引用变量","date":"2016-12-22T07:45:35.000Z","path":"2016/12/22/基本变量-引用变量/","text":"js 中包含两种不同数据类型的值- 基本类型值 1. undefined 2. Null 3. Boolean 4. Number 5. String - 引用类型值 1. Object 2. Array 3. Function 4. 基本包装类型 ... 下面说说我的理解 一: 对于 基本类型值 复制操作时,12var num1 = 5var num2 = num1 结果: 变量名 内存中 num1 5 (内存中有自己的位置) num2 5 (内存中有自己的位置) 对于 引用类型值 复制操作时,12var obj1 = &#123; key: &apos;value&apos;&#125;var obj2 = obj1 结果: 变量名 内存中 obj1 { key: ‘value’} (内存中有自己的位置) obj2 obj1 (内存中没有自己的位置，而是引用 obj1 的内存地址) 二：引用类型值 可以为其添加属性和方法 ,而 基本类型 则不可以1234567var person = &#123;&#125;person.name = \"Rabbit\"alert(person.name) // ''Rabbit''//var name = \"Banana\"name.age = 24alert(name.age) // undefined, 因为 基本类型 不能添加属性 age 三:传递参数:基本类型传递参数是复制一个值给参数1234567var addTen = function(num) &#123; return num+10&#125;var a = 10var r = addTen(r)alert(a) // 10, a 还是 10,没有变化, addTen 函数操作并不是 a 变量 引用类型传递参数是把它的地址传递给参数123456var setName = function(obj) &#123; obj.name = 'pinkBao'&#125;var person = &#123;&#125;setName(person)alert(person.name) // 'pinkBao', 因为引用类型传递参数是把它的地址传递给参数,所以 setName 函数操作的实际上是 person 这个对象","categories":[],"tags":[{"name":"js高程读书笔记","slug":"js高程读书笔记","permalink":"http://yoursite.com/tags/js高程读书笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"部署个人博客 hexo","date":"2016-12-21T18:31:58.000Z","path":"2016/12/22/部署个人博客-hexo/","text":"之前听萧大说过 HEXO 部署个人静态博客, 这几天试了一下，发现他的优点挺多的 简单。 有很多主题可以选。 静态页面，可以上传到 GitHub Pages 做自己的主页。（配置下 HEXO 就可以很简单上传） 写文章便携，只需用 markdown 语法写出文章，剩下的就交给 HEXO 去处理。 接着我就试着搭起了自己人生中的第一个博客。接下来记录一下我怎么搭 HEXO。 开发环境为: ubuntu 16.04 1. 安装 node.js2. 安装 git3. 安装 hexo1$ npm install -g hexo # -g 代表是全局安装，也就是安装在 个人主目录的 .npm-global 中 4. 现在开始搭建个人博客一些 hexo 的常用指令 1234hexo init # 开始初始化hexo new '文章名字' # 新建一篇文章hexo g # 生成个人博客hexo s # 在本地启动个人博客 1. 首先新建一个文件夹用来生成 hexo`$ mkdir hexo #新建文件夹` `$ cd hexo #切换到 hexo 文件夹下` 2. 初始化这个文件夹`$ hexo init` 3. 切换到 blog 目录下 (此目录可以为博客的根目录)`$ cd blog` 4. 新建一篇文章 (新建后的文章在 source/_posts/ 中可看到)`$ hexo new &quot;halo world&quot;` 5. 用 markdown 语法写自己的文章 (即编写 source/_posts/halo-world.md)6. 生成 html 文件 (在 blog 目录执行此命令)`$ hexo g` 7. 启动本地服务`$ hexo s` 大功告成，现在可以在浏览器中输入 localhost:4000 访问自己的博客了","categories":[],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/tags/工具使用/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"逻辑‘与和或’操作","date":"2016-12-21T17:11:25.000Z","path":"2016/12/22/逻辑‘与和或’操作/","text":"逻辑‘与和或’操作 js 中的逻辑‘与和或’操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。 以 逻辑与 为例， 第一操作数为false，则返回 false，不执行第二个操作数（即使第二个操作数 有错误） 1234var a = falsevar result = (a &amp;&amp; someUndefinedVar) // 没有发生错误，因为 someUndefinedVar 没有执行var b = truevar result = (b &amp;&amp; someUndefinedVar) // 发生错误: someUndefinedVar is no defined 同理对于 逻辑或， 第一操作数为true，则返回 true，不执行第二个操作数（即使第二个操作数 有错误） 逻辑‘与和或’操作可以适用于任何类型的操作数，而不仅仅是布尔值。 在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值 123456789101112131415161718 // 以 逻辑与 为例var obj1 = &#123; a: 'b'&#125;var c = 'Halo'var r1 = obj1 &amp;&amp; cconsole.log(r1) // r1 = c ，因为 obj1 转换为布尔值为 true， 则接着执行第二个操作数，结果返回第二个操作数var t = truevar r2 = t &amp;&amp; objconsole.log(r2) // r2 = obj1 ，根据笔记 2 返回 obj1var obj2 = &#123; d: 'e'&#125;var r3 = obj1 &amp;&amp; obj2console.log(r3) // r3 = obj2, 因为 obj1 转换为布尔值为 true，接着执行第二个操作数，返回 obj2 逻辑 ‘与’ 中的某一操作数为 null undefined NaN,则对应返回 null undefined NaN 若 逻辑操作 中既有 null 也有 NaN， 则根据短路操作先遇到谁就返回谁123// 例var r = null &amp;&amp; undefinedconsole.log(r) // r = null, 因为先遇到 null ，由于短路操作，第二操作数不执行，直接返回 null 逻辑 ‘或’ 中的两个操作数都为 null undefined NaN,才返回 null undefined NaN 若 逻辑操作 中既有 null 也有 NaN， 则根据笔记 2 返回第二个操作数123// 例var r = null || undefinedconsole.log(r) // r = undefined, 因为先遇到 null ，null 转化为布尔值为 false，所以接着执行第二操作数，根据笔记 2 返回第二操作数 注：以上知识不建议用在日常代码中， 对于一个大项目，进行迭代，你就要回去看自己的代码，而以上知识不常用，这样写以后 debug 会就不容易最好的写法是，直接明了的,如: 12345if(condition)&#123; a = a + b&#125; else &#123; a = a + c&#125; 这样即好理解，也容易 debug","categories":[{"name":"js 高程读书笔记","slug":"js-高程读书笔记","permalink":"http://yoursite.com/categories/js-高程读书笔记/"}],"tags":[{"name":"js高程读书笔记","slug":"js高程读书笔记","permalink":"http://yoursite.com/tags/js高程读书笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]